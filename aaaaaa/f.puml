@startuml
class Image {
    + Width : int
    + Height : int
    + Delay : int
    + RawImage : Color32[]
    + Image()
    + Image(img:Image)
    + Clone() : object
    + CreateTexture() : Texture2D
}
class Decoder {
    + Version : string
    + Width : ushort
    + Height : ushort
    + BackgroundColour : Color32
    <<const>> - NoCode : uint = 0xFFFF
    <<const>> - NoTransparency : ushort = 0xFFFF
    - Input : byte[]
    - D : int
    - GlobalColourTable : Color32[]
    - LocalColourTable : Color32[]
    - ActiveColourTable : Color32[]
    - TransparentIndex : ushort
    - Image : Image
    - ImageLeft : ushort
    - ImageTop : ushort
    - ImageWidth : ushort
    - ImageHeight : ushort
    - Output : Color32[]
    - PreviousImage : Color32[]
    <<readonly>> - Pow2 : int[]
    + Decoder(data:byte[])
    + Load(data:byte[]) : Decoder
    - ReadByte() : byte
    - ReadUInt16() : ushort
    - ReadHeader() : void
    + NextImage() : Image
    - ReadColourTable(colourTable:Color32[], flags:ImageFlag) : Color32[]
    - SkipBlocks() : void
    - ReadControlBlock() : void
    - ReadImageBlock() : Image
    - Deinterlace() : void
    + Decoder()
    + Dispose() : void
    # <<virtual>> Dispose(disposing:bool) : void
    - Indices : int[]
    - Codes : ushort[]
    - CurBlock : uint[]
    - DecompressLZW() : void
    + {static} Ident() : string
}
enum ImageFlag {
    Interlaced= 0x40,
    ColourTable= 0x80,
    TableSizeMask= 0x07,
    BitDepthMask= 0x70,
}
enum Block {
    Image= 0x2C,
    Extension= 0x21,
    End= 0x3B,
}
enum Extension {
    GraphicControl= 0xF9,
    Comments= 0xFE,
    PlainText= 0x01,
    ApplicationData= 0xFF,
}
enum Disposal {
    None= 0x00,
    DoNotDispose= 0x04,
    RestoreBackground= 0x08,
    ReturnToPrevious= 0x0C,
}
enum ControlFlags {
    HasTransparency= 0x01,
    DisposalMask= 0x0C,
}
ICloneable <|-- Image
IDisposable <|-- Decoder
Decoder +-- ImageFlag
Decoder +-- Block
Decoder +-- Extension
Decoder +-- Disposal
Decoder +-- ControlFlags
@enduml
